
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vova4o/yandexadv/cmd/agent/main.go (0.0%)</option>
				
				<option value="file1">github.com/vova4o/yandexadv/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/vova4o/yandexadv/internal/agent/collector/collector.go (100.0%)</option>
				
				<option value="file3">github.com/vova4o/yandexadv/internal/agent/flags/flags.go (83.3%)</option>
				
				<option value="file4">github.com/vova4o/yandexadv/internal/agent/sender/sender.go (0.0%)</option>
				
				<option value="file5">github.com/vova4o/yandexadv/internal/models/models.go (50.0%)</option>
				
				<option value="file6">github.com/vova4o/yandexadv/internal/server/flags/flags.go (83.9%)</option>
				
				<option value="file7">github.com/vova4o/yandexadv/internal/server/handler/handlers.go (51.9%)</option>
				
				<option value="file8">github.com/vova4o/yandexadv/internal/server/handler/router.go (14.3%)</option>
				
				<option value="file9">github.com/vova4o/yandexadv/internal/server/service/service.go (37.3%)</option>
				
				<option value="file10">github.com/vova4o/yandexadv/internal/server/storage/storage.go (93.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "sync"
        "time"

        "github.com/vova4o/yandexadv/internal/agent/collector"
        "github.com/vova4o/yandexadv/internal/agent/flags"
        "github.com/vova4o/yandexadv/internal/agent/metrics"
        "github.com/vova4o/yandexadv/internal/agent/sender"
)

// change this later to a config stuct
var (
    pollCount      int64
    metricsData    []metrics.Metric
    metricsMutex   sync.Mutex
)

func main() <span class="cov0" title="0">{
    config := flags.NewConfig()

    tickerPoll := time.NewTicker(config.PollInterval)
    tickerReport := time.NewTicker(config.ReportInterval)

    for </span><span class="cov0" title="0">{
        select </span>{
        case &lt;-tickerPoll.C:<span class="cov0" title="0">
            pollCount++
            metricsMutex.Lock()
            metricsData = collector.CollectMetrics(pollCount)
            metricsMutex.Unlock()</span>

        case &lt;-tickerReport.C:<span class="cov0" title="0">
            metricsMutex.Lock()
            sender.SendMetrics(config.ServerAddress, metricsData)
            metricsMutex.Unlock()
            fmt.Println("Sent metrics")</span>
        }
    }
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"

        "github.com/vova4o/yandexadv/internal/server/flags"
        "github.com/vova4o/yandexadv/internal/server/handler"
        "github.com/vova4o/yandexadv/internal/server/service"
        "github.com/vova4o/yandexadv/internal/server/storage"
)

func main() <span class="cov0" title="0">{
        config := flags.NewConfig()

        storage := storage.New()
        
        service := service.New(storage)

        router := handler.New(service)
        router.RegisterRoutes()

        log.Println("Starting server on "+ config.ServerAddress)
        if err := router.StartServer(config.ServerAddress); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package collector

import (
        "math/rand"
        "runtime"

        "github.com/vova4o/yandexadv/internal/agent/metrics"
)

// CollectMetrics собирает метрики и возвращает их
func CollectMetrics(pollCount int64) []metrics.Metric <span class="cov8" title="1">{
    var m runtime.MemStats
    runtime.ReadMemStats(&amp;m)

    return []metrics.Metric{
        {Name: "Alloc", Type: "gauge", Value: float64(m.Alloc)},
        {Name: "BuckHashSys", Type: "gauge", Value: float64(m.BuckHashSys)},
        {Name: "Frees", Type: "gauge", Value: float64(m.Frees)},
        {Name: "GCCPUFraction", Type: "gauge", Value: m.GCCPUFraction},
        {Name: "GCSys", Type: "gauge", Value: float64(m.GCSys)},
        {Name: "HeapAlloc", Type: "gauge", Value: float64(m.HeapAlloc)},
        {Name: "HeapIdle", Type: "gauge", Value: float64(m.HeapIdle)},
        {Name: "HeapInuse", Type: "gauge", Value: float64(m.HeapInuse)},
        {Name: "HeapObjects", Type: "gauge", Value: float64(m.HeapObjects)},
        {Name: "HeapReleased", Type: "gauge", Value: float64(m.HeapReleased)},
        {Name: "HeapSys", Type: "gauge", Value: float64(m.HeapSys)},
        {Name: "LastGC", Type: "gauge", Value: float64(m.LastGC)},
        {Name: "Lookups", Type: "gauge", Value: float64(m.Lookups)},
        {Name: "MCacheInuse", Type: "gauge", Value: float64(m.MCacheInuse)},
        {Name: "MCacheSys", Type: "gauge", Value: float64(m.MCacheSys)},
        {Name: "MSpanInuse", Type: "gauge", Value: float64(m.MSpanInuse)},
        {Name: "MSpanSys", Type: "gauge", Value: float64(m.MSpanSys)},
        {Name: "Mallocs", Type: "gauge", Value: float64(m.Mallocs)},
        {Name: "NextGC", Type: "gauge", Value: float64(m.NextGC)},
        {Name: "NumForcedGC", Type: "gauge", Value: float64(m.NumForcedGC)},
        {Name: "NumGC", Type: "gauge", Value: float64(m.NumGC)},
        {Name: "OtherSys", Type: "gauge", Value: float64(m.OtherSys)},
        {Name: "PauseTotalNs", Type: "gauge", Value: float64(m.PauseTotalNs)},
        {Name: "StackInuse", Type: "gauge", Value: float64(m.StackInuse)},
        {Name: "StackSys", Type: "gauge", Value: float64(m.StackSys)},
        {Name: "Sys", Type: "gauge", Value: float64(m.Sys)},
        {Name: "TotalAlloc", Type: "gauge", Value: float64(m.TotalAlloc)},
        {Name: "PollCount", Type: "counter", Value: int64(pollCount)},
        {Name: "RandomValue", Type: "gauge", Value: rand.Float64()},
    }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package flags

import (
        "log"
        "strings"
        "time"

        "github.com/spf13/pflag"
        "github.com/spf13/viper"
)

// Config структура конфигурации
type Config struct {
        ServerAddress  string
        ReportInterval time.Duration
        PollInterval   time.Duration
}

// GetFlags устанавливает и получает флаги
func GetFlags() <span class="cov8" title="1">{
        // Define the flags and bind them to viper
        pflag.StringP("ServerAddress", "a", "localhost:8080", "HTTP server network address")
        pflag.IntP("ReportInterval", "r", 10, "Interval between fetching reportable metrics in seconds")
        pflag.IntP("PollInterval", "p", 2, "Interval between polling metrics in seconds")

        // Parse the command-line flags
    pflag.Parse()

    // Check for unknown flags
    for _, arg := range pflag.Args() </span><span class="cov0" title="0">{
        if !strings.HasPrefix(arg, "-") </span><span class="cov0" title="0">{
            log.Fatalf("Unknown flag: %v", arg)
        }</span>
    }

        // Bind the flags to viper
        <span class="cov8" title="1">bindFlagToViper("ServerAddress")
        bindFlagToViper("ReportInterval")
        bindFlagToViper("PollInterval")

        // Set the environment variable names
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        bindEnvToViper("ServerAddress", "ADDRESS")
        bindEnvToViper("ReportInterval", "REPORT_INTERVAL")
        bindEnvToViper("PollInterval", "POLL_INTERVAL")

        // Read the environment variables
        viper.AutomaticEnv()</span>
}

func bindFlagToViper(flagName string) <span class="cov8" title="1">{
        if err := viper.BindPFlag(flagName, pflag.Lookup(flagName)); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func bindEnvToViper(viperKey, envKey string) <span class="cov8" title="1">{
        if err := viper.BindEnv(viperKey, envKey); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

// NewConfig создает новую конфигурацию
func NewConfig() *Config <span class="cov8" title="1">{
        GetFlags()
        return &amp;Config{
                ServerAddress:  GetServerAddress(),
                ReportInterval: GetReportInterval(),
                PollInterval:   GetPollInterval(),
        }
}</span>

// GetServerAddress возвращает адрес сервера
func GetServerAddress() string <span class="cov8" title="1">{
        return viper.GetString("ServerAddress")
}</span>

// GetReportInterval возвращает интервал для отправки метрик
func GetReportInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(viper.GetInt("ReportInterval")) * time.Second
}</span>

// GetPollInterval возвращает интервал получения метрик
func GetPollInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(viper.GetInt("PollInterval")) * time.Second
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package sender

import (
        "fmt"

        "github.com/go-resty/resty/v2"
        "github.com/vova4o/yandexadv/internal/agent/metrics"
)

// SendMetrics отправляет метрики на сервер
func SendMetrics(address string, metricsData []metrics.Metric) <span class="cov0" title="0">{
        client := resty.New()

        for _, metric := range metricsData </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s/update/%s/%s/%v",address, metric.Type, metric.Name, metric.Value)
                resp, err := client.R().
                        SetHeader("Content-Type", "text/plain").
                        Post(url)

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to send metric %s: %v\n", metric.Name, err)
                        continue</span>
                }

                <span class="cov0" title="0">if resp.StatusCode() != 200 </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to send metric %s: status code %d\n", metric.Name, resp.StatusCode())
                }</span>
        }
}</pre>
		
		<pre class="file" id="file5" style="display: none">package models

type Metric struct {
        Type  string `json:"type"`
        Name  string `json:"name"`
        Value interface{} `json:"value"`
}

// HTTPError структура для ошибок с HTTP-статусом
type HTTPError struct {
        Status  int
        Message string
}

// Error реализация интерфейса ошибки
func (e *HTTPError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewHTTPError создание новой ошибки с HTTP-статусом
func NewHTTPError(status int, message string) *HTTPError <span class="cov8" title="1">{
        return &amp;HTTPError{
                Status:  status,
                Message: message,
        }
}</pre>
		
		<pre class="file" id="file6" style="display: none">package flags

import (
        "log"
        "strings"

        "github.com/spf13/pflag"
        "github.com/spf13/viper"
)

// Config структура конфигурации
type Config struct {
        ServerAddress   string
        StoreInterval   int
        FileStoragePath string
        Restore         bool
}

// GetFlags устанавливает и получает флаги
func GetFlags() <span class="cov8" title="1">{
        // Define the flags and bind them to viper
        pflag.StringP("ServerAddress", "a", "localhost:8080", "HTTP server network address")
        pflag.IntP("StoreInterval", "i", 300, "Interval in seconds to store the current server readings to disk")
        pflag.StringP("FileStoragePath", "f", "/tmp/metrics-db.json", "Full filename where current values are saved")
        pflag.BoolP("Restore", "r", true, "Whether to load previously saved values from the specified file at server startup")

        // Parse the command-line flags
    pflag.Parse()

    // Check for unknown flags
    for _, arg := range pflag.Args() </span><span class="cov0" title="0">{
        if !strings.HasPrefix(arg, "-") </span><span class="cov0" title="0">{
            log.Fatalf("Unknown flag: %v", arg)
        }</span>
    }
        
        // Bind the flags to viper
        <span class="cov8" title="1">bindFlagToViper("ServerAddress")
        bindFlagToViper("StoreInterval")
        bindFlagToViper("FileStoragePath")
        bindFlagToViper("Restore")

        // Set the environment variable names
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        bindEnvToViper("ServerAddress", "ADDRESS")
        bindEnvToViper("StoreInterval", "STORE_INTERVAL")
        bindEnvToViper("FileStoragePath", "FILE_STORAGE_PATH")
        bindEnvToViper("Restore", "RESTORE")

        // Read the environment variables
        viper.AutomaticEnv()</span>
}

func bindFlagToViper(flagName string) <span class="cov8" title="1">{
        if err := viper.BindPFlag(flagName, pflag.Lookup(flagName)); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func bindEnvToViper(viperKey, envKey string) <span class="cov8" title="1">{
        if err := viper.BindEnv(viperKey, envKey); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

// NewConfig создает новый экземпляр конфигурации
func NewConfig() *Config <span class="cov8" title="1">{
        GetFlags()
        return &amp;Config{
                ServerAddress:   Address(),
                StoreInterval:   Interval(),
                FileStoragePath: FileStoragePath(),
                Restore:         Restore(),
        }
}</span>

// Address возвращает адрес сервера
func Address() string <span class="cov8" title="1">{
        return viper.GetString("ServerAddress")
}</span>

// Interval возвращает интервал сохранения текущих значений сервера на диск
func Interval() int <span class="cov8" title="1">{
        return viper.GetInt("StoreInterval")
}</span>

// FileStoragePath возвращает путь к файлу хранения
func FileStoragePath() string <span class="cov8" title="1">{
    path := viper.GetString("FileStoragePath")
    if path == "=" </span><span class="cov0" title="0">{
        return ""
    }</span>
    <span class="cov8" title="1">return path</span>
}

// Restore возвращает флаг восстановления
func Restore() bool <span class="cov8" title="1">{
        return viper.GetBool("Restore")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "bytes"
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/vova4o/yandexadv/internal/models"
)

// StatisticPage обработчик для страницы статистики
func (s *Router) StatisticPage(c *gin.Context) <span class="cov0" title="0">{
    tmpl, metrics, err := s.Service.MetrixStatistic()
    if err != nil </span><span class="cov0" title="0">{
        c.String(http.StatusInternalServerError, "internal server error")
        return
    }</span>

    <span class="cov0" title="0">var buf bytes.Buffer
    if err := tmpl.Execute(&amp;buf, metrics); err != nil </span><span class="cov0" title="0">{
        c.String(http.StatusInternalServerError, "internal server error")
        return
    }</span>

    <span class="cov0" title="0">c.Header("Content-Type", "text/html")
    c.String(http.StatusOK, buf.String())</span>
}

// UpdateMetricHandler обработчик для обновления метрики
func (s *Router) UpdateMetricHandler(c *gin.Context) <span class="cov8" title="1">{
    metric := models.Metric{
        Type:  c.Param("type"),
        Name:  c.Param("name"),
        Value: c.Param("value"),
    }
    
    err := s.Service.UpdateServ(metric)
    if err != nil </span><span class="cov8" title="1">{
        if httpErr, ok := err.(*models.HTTPError); ok </span><span class="cov0" title="0">{
            log.Printf("Error: %v", httpErr.Message)
            c.String(httpErr.Status, httpErr.Message)
            return
        }</span>
        <span class="cov8" title="1">log.Printf("Internal server error: %v", err)
        c.String(http.StatusInternalServerError, "internal server error")
        return</span>
    }

    <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

// GetValueHandler обработчик для получения значения метрики
func (s *Router) GetValueHandler(c *gin.Context) <span class="cov8" title="1">{    
    metric := models.Metric{
        Type: c.Param("type"),
        Name: c.Param("name"),
    }
    
    value, err := s.Service.GetValueServ(metric)
    if err != nil </span><span class="cov8" title="1">{
        c.String(http.StatusNotFound, "metric not found")
        return
    }</span>

    <span class="cov8" title="1">c.String(http.StatusOK, value)</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "html/template"

        "github.com/gin-gonic/gin"
        "github.com/vova4o/yandexadv/internal/models"
)

// Router структура для роутера
type Router struct {
    mux *gin.Engine
        Service Servicer
}

// Servicer интерфейс для сервиса
type Servicer interface {
        UpdateServ(metric models.Metric) error
    GetValueServ(metric models.Metric) (string, error)
    MetrixStatistic() (*template.Template,map[string]interface{}, error)
}

// New создание нового роутера
func New(s Servicer) *Router <span class="cov8" title="1">{
    return &amp;Router{
        mux:    gin.Default(),
                Service: s,
    }
}</span>

// RegisterRoutes регистрация маршрутов
func (s *Router) RegisterRoutes() <span class="cov0" title="0">{
    s.mux.POST("/update/:type/:name/:value", s.UpdateMetricHandler)
    s.mux.GET("/value/:type/:name", s.GetValueHandler)
    s.mux.GET("/", s.StatisticPage)
}</span>

// StartServer запуск сервера
func (s *Router) StartServer(addr string) error <span class="cov0" title="0">{
    // Запуск сервера с использованием Gin
    if err := s.mux.Run(addr); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov0" title="0">return nil</span>
}


</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "fmt"
        "html/template"
        "log"
        "net/http"
        "strconv"

        "github.com/vova4o/yandexadv/internal/models"
)

// Service структура для бизнес-логики
type Service struct {
        Storage Storager
}

// Storager интерфейс для хранилища
type Storager interface {
        UpdateMetric(metric models.Metric) error
        GetValue(metric models.Metric) (interface{}, error)
        MetrixStatistic() (map[string]interface{}, error)
}

// New создание нового сервиса
func New(s Storager) *Service <span class="cov8" title="1">{
        return &amp;Service{
                Storage: s,
        }
}</span>

// MetrixStatistic получение статистики метрик
func (s *Service) MetrixStatistic() (*template.Template, map[string]interface{}, error) <span class="cov0" title="0">{
        metrics, err := s.Storage.MetrixStatistic()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to get metrics: %v", err)
                return nil, nil, models.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf("failed to get metrics: %v", err))
        }</span>

        <span class="cov0" title="0">tmpl, err := template.New("metrics").Parse(`
         &lt;!DOCTYPE html&gt;
                &lt;html&gt;
                &lt;head&gt;
                        &lt;title&gt;Metrics Statistics&lt;/title&gt;
                &lt;/head&gt;
                &lt;body&gt;
                        &lt;h1&gt;Metrics Statistics&lt;/h1&gt;
                        &lt;table border="1"&gt;
                                &lt;tr&gt;
                                        &lt;th&gt;Metric Name&lt;/th&gt;
                                        &lt;th&gt;Metric Value&lt;/th&gt;
                                &lt;/tr&gt;
                                {{range $key, $metric := .}}
                                &lt;tr&gt;
                                        &lt;td&gt;{{$key}}&lt;/td&gt;
                                        &lt;td&gt;{{$metric.Value}}&lt;/td&gt;
                                &lt;/tr&gt;
                                {{end}}
                        &lt;/table&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to parse template: %v", err)
                return nil, nil, models.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf("failed to parse template: %v", err))
        }</span>

        <span class="cov0" title="0">return tmpl, metrics, nil</span>
}

// GetValueServ получение значения метрики
func (s *Service) GetValueServ(metric models.Metric) (string, error) <span class="cov8" title="1">{
    // Проверка метрики
    if err := validateMetric(metric); err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>

        <span class="cov8" title="1">value, err := s.Storage.GetValue(metric)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to get value: %v", err)
                return "", models.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf("failed to get value: %v", err))
        }</span>

        // TODO: make sparate function for this
        <span class="cov8" title="1">valueStr := fmt.Sprintf("%v", value)
        
        return valueStr, nil</span>
}


// UpdateServ обновление метрики
func (s *Service) UpdateServ(metric models.Metric) error <span class="cov8" title="1">{
    // Проверка метрики
    if err := validateMetric(metric); err != nil </span><span class="cov8" title="1">{
        return err
    }</span>

    <span class="cov8" title="1">switch metric.Type </span>{
    case "gauge":<span class="cov8" title="1">
        strValue, ok := metric.Value.(string)
        if !ok </span><span class="cov0" title="0">{
            log.Println("metricValue must be a string for gauge type")
            return models.NewHTTPError(http.StatusBadRequest, "metricValue must be a string for gauge type")
        }</span>
        <span class="cov8" title="1">value, err := strconv.ParseFloat(strValue, 64)
        if err != nil </span><span class="cov0" title="0">{
            log.Printf("invalid gauge value: %v", err)
            return models.NewHTTPError(http.StatusBadRequest, "invalid gauge value")
        }</span>
        <span class="cov8" title="1">s.Storage.UpdateMetric(models.Metric{
            Type:  metric.Type,
            Name:  metric.Name,
            Value: value,
        })</span>
    case "counter":<span class="cov0" title="0">
        // Получение старого значения счетчика
        counterVal, _ := s.GetValueServ(metric)
        // if counterVal == ""{
                // } else {
                //         err != nil {
        //     log.Printf("failed to get value: %v", err)
        //     // return models.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf("failed to get value: %v", err))
        // } 
                //         }

        // Инициализация значения счетчика, если оно не существует
        var counterInt int 
                var err error
        if counterVal == "" </span><span class="cov0" title="0">{
            counterInt = 0
        }</span> else<span class="cov0" title="0"> {
            counterInt, err = strconv.Atoi(counterVal)
            if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to convert value to int: %v", err)
                return models.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf("failed to convert value to int: %v", err))
            }</span>
        }

        <span class="cov0" title="0">strValue, ok := metric.Value.(string)
        if !ok </span><span class="cov0" title="0">{
            log.Println("metricValue must be a string for counter type")
            return models.NewHTTPError(http.StatusBadRequest, "metricValue must be a string for counter type")
        }</span>
        <span class="cov0" title="0">newValue, err := strconv.ParseInt(strValue, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
            log.Printf("invalid counter value: %v", err)
            return models.NewHTTPError(http.StatusBadRequest, "invalid counter value")
        }</span>

        // Добавление старого значения к новому
        <span class="cov0" title="0">totalValue := newValue + int64(counterInt)
        s.Storage.UpdateMetric(models.Metric{
            Type:  metric.Type,
            Name:  metric.Name,
            Value: totalValue,
        })</span>
    default:<span class="cov0" title="0">
        log.Printf("unknown metric type: %s", metric.Type)
        return models.NewHTTPError(http.StatusBadRequest, "unknown metric type")</span>
    }

    <span class="cov8" title="1">return nil</span>
}

// validateMetric проверяет метрику на наличие ошибок
func validateMetric(metric models.Metric) error <span class="cov8" title="1">{
    if metric.Type == "" || metric.Value == "" </span><span class="cov8" title="1">{
        log.Println("metric cannot be empty")
        return models.NewHTTPError(http.StatusBadRequest, "metricType cannot be empty")
    }</span>

    <span class="cov8" title="1">if metric.Name == "" </span><span class="cov8" title="1">{
        log.Println("metricName cannot be empty")
        return models.NewHTTPError(http.StatusNotFound, "metricName cannot be empty")
    }</span>

    <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package storage

import (
        "errors"
        "sync"

        "github.com/vova4o/yandexadv/internal/models"
)

// Storage структура для хранилища
type Storage struct {
        MemStorage map[string]models.Metric
        mu            sync.Mutex
}

// gauge - тип метрики
// a:val,b:val,c,d,e - метрики
// counter - тип метрики
// PollCount:val

// Ошибки
var (
    ErrMetricTypeNotFound = errors.New("metric type not found")
    ErrMetricNotFound     = errors.New("metric not found")
)

// New создание нового хранилища
func New() *Storage <span class="cov8" title="1">{
        return &amp;Storage{
                MemStorage: make(map[string]models.Metric),
        }
}</span>

// MetrixStatistic получение статистики метрик
func (s *Storage) MetrixStatistic() (map[string]interface{}, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var metrics =  make(map[string]interface{})

        for metricType, metricValues := range s.MemStorage </span><span class="cov0" title="0">{
                metrics[metricType] = metricValues
        }</span>

        <span class="cov8" title="1">return metrics, nil</span>
}

// UpdateMetric обновление метрики
func (s *Storage) UpdateMetric(metric models.Metric) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.MemStorage[metric.Name] = metric
        return nil
}</span>

// GetValue получение значения метрики
func (s *Storage) GetValue(metric models.Metric) (interface{}, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        
        if value, ok := s.MemStorage[metric.Name]; ok </span><span class="cov8" title="1">{
                return value.Value, nil
        }</span>

        <span class="cov8" title="1">return "", ErrMetricNotFound</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
